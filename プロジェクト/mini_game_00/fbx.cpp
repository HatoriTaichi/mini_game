//=============================================================================
//
// fbxモデル処理 [fbx.cpp]
// Author : 羽鳥太一
//
//=============================================================================
//=============================================================================
// インクルード
//=============================================================================
#include "fbx.h"
#include "manager.h"
#include "renderer.h"

//=============================================================================
// 静的メンバ変数宣言
//=============================================================================
bool CFbx::m_is_bone = false;

//=============================================================================
// コンストラクタ
//=============================================================================
CFbx::CFbx()
{
	m_vertex_ary.clear();
	m_mormal_ary.clear();
	m_uv_ary.clear();
	m_material.clear();
	m_tex.clear();
	m_index_number.clear();
	m_vtx_buff.clear();
	m_idx_buff.clear();
	D3DXMatrixIdentity(&m_mtx_wold);
	m_pas.clear();
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_scale = D3DXVECTOR3(1.0f, 1.0f, 1.0f);
	m_is_bone = false;
}

//=============================================================================
// デストラクタ
//=============================================================================
CFbx::~CFbx()
{

}

//=============================================================================
// 初期化
//=============================================================================
HRESULT CFbx::Init(void)
{
	m_manager = FbxManager::Create();	// fbxマネージャーの生成
	m_importer = FbxImporter::Create(m_manager, "Importer");	// fbxインポーターの生成
	m_scene = FbxScene::Create(m_manager, "Scene");	// fbxシーンの生成
	LPDIRECT3DDEVICE9 device = CManager::GetInstance()->GetRenderer()->GetDevice();	// デバイスの取得

	// インポーターでファイルの初期化
	m_importer->Initialize(m_pas.c_str());

	// インポーターでシーンに情報を渡す
	m_importer->Import(m_scene);

	// 四角形ポリゴンを三角形ポリゴンに直す
	FbxGeometryConverter converter(m_manager);
	converter.Triangulate(m_scene, true);

	// ルートノードを取得
	FbxNode *root_node = m_scene->GetRootNode();

	// ノードの情報を再帰処理で取得
	RecursiveNode(root_node);

	// メッシュ数を取得
	int mesh_size = m_mesh.size();

	// メッシュ分のループ
	for (int count_mesh = 0; count_mesh < mesh_size; count_mesh++)
	{
		LPDIRECT3DVERTEXBUFFER9 buf = nullptr;	// 頂点バッファ
		VERTEX_3D *vtx;	// 頂点情報
		int vertex_size = m_vertex_ary[count_mesh].size();	// 頂点サイズの取得
		int uv_size = m_uv_ary[count_mesh].size();	// uvサイズの取得

		// 頂点バッファの生成
		device->CreateVertexBuffer(	sizeof(VERTEX_3D) * vertex_size,
									D3DUSAGE_WRITEONLY,
									FVF_VERTEX_3D,
									D3DPOOL_MANAGED,
									&buf,
									NULL);

		// 頂点バッファをロックし、頂点データへのポインタを取得
		buf->Lock(0, 0, (void**)&vtx, 0);

		// 頂点サイズ分のループ
		for (int count_vertex = 0; count_vertex < vertex_size; count_vertex++)
		{
			// 頂上情報を設定
			vtx[count_vertex].pos = D3DXVECTOR3(m_vertex_ary[count_mesh][count_vertex].x, m_vertex_ary[count_mesh][count_vertex].y, m_vertex_ary[count_mesh][count_vertex].z);
			vtx[count_vertex].col = D3DCOLOR_RGBA(255, 255, 255, 255);
			vtx[count_vertex].nor = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
			if (uv_size > 0)
			{
				//vtx[count_vertex].tex = D3DXVECTOR2(m_uv_ary[count_mesh][count_vertex].x, m_uv_ary[count_mesh][count_vertex].y);
			}
		}

		// 頂点バッファをアンロックする
		buf->Unlock();

		// 頂点バッファの保存
		m_vtx_buff.push_back(buf);
	}

	// メッシュ分のループ
	for (int count_mesh = 0; count_mesh < mesh_size; count_mesh++)
	{
		LPDIRECT3DINDEXBUFFER9 buf;	// インデックスバッファ
		WORD *indx;	// インデックス情報
		int index_size = m_index_number[count_mesh].size();	// インデックスのサイズを取得

		// インデックスバッファの生成
		device->CreateIndexBuffer(	sizeof(WORD) * index_size,
									D3DUSAGE_WRITEONLY,
									D3DFMT_INDEX16,
									D3DPOOL_MANAGED,
									&buf,
									nullptr);

		// インデックスバッファをロックし、インデックスデータへのポインタを取得
		buf->Lock(0, 0, (void**)&indx, 0);

		// インデックス分のループ
		for (int count_index = 0; count_index < index_size; count_index++)
		{
			// インデックスの設定
			indx[count_index] = m_index_number[count_mesh][count_index];
		}

		// インデックスバッファをアンロックする
		buf->Unlock();

		// インデックスバッファの保存
		m_idx_buff.push_back(buf);
	}

	return S_OK;
}

//=============================================================================
// 終了
//=============================================================================
void CFbx::Uninit(void)
{
	// 頂点バッファサイズを取得
	int vtx_size = m_vtx_buff.size();

	// 頂点バッファ数分のループ
	for (int count_tvx = 0; count_tvx < vtx_size; count_tvx++)
	{
		//頂点バッファの破棄
		if (m_vtx_buff[count_tvx] != nullptr)
		{
			m_vtx_buff[count_tvx]->Release();
			m_vtx_buff[count_tvx] = nullptr;
		}
	}

	// インデックスバッファサイズを取得
	int index_size = m_idx_buff.size();

	// インデックスバッファ数分のループ
	for (int count_index = 0; count_index < index_size; count_index++)
	{
		//インデックスバッファの破棄
		if (m_idx_buff[count_index] != nullptr)
		{
			m_idx_buff[count_index]->Release();
			m_idx_buff[count_index] = nullptr;
		}
	}

	// データの破棄
	m_vertex_ary.clear();
	m_mormal_ary.clear();
	m_uv_ary.clear();
	m_material.clear();
	m_tex.clear();
	m_index_number.clear();
	D3DXMatrixIdentity(&m_mtx_wold);
	m_pas.clear();
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_scale = D3DXVECTOR3(1.0f, 1.0f, 1.0f);
	m_vtx_buff.clear();
	m_idx_buff.clear();
	m_manager->Destroy();
	m_importer->Destroy();
	m_scene->Destroy();
	m_is_bone = false;
}

//=============================================================================
// 更新
//=============================================================================
void CFbx::Update(void)
{
	// カウントアップ
	m_count++;
	if (m_count >= 1)
	{
		m_frame_count_old = m_frame_count;
		m_frame_count++;
		m_count = 0;
	}
}

//=============================================================================
// 描画
//=============================================================================
void CFbx::Draw(void)
{
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();	//デバイスのポインタ
	D3DXMATRIX mtx_scale, mtx_rot, mtx_trans, mtx_parent;	// 計算用マトリックス
	int mesh_size = m_mesh.size();	// メッシュ数を取得

	// ボーンなしだったら
	if (!m_is_bone)
	{
		// 勝手にスケールされている分を戻す
		m_scale = D3DXVECTOR3(1.0f / m_fbx_scale.x, 1.0f / m_fbx_scale.y, 1.0f / m_fbx_scale.z);
	}

	// マトリックス初期化
	D3DXMatrixIdentity(&m_mtx_wold);

	// スケールの設定
	D3DXMatrixScaling(	&mtx_scale,
						m_scale.x,
						m_scale.y,
						m_scale.z);

	D3DXMatrixMultiply(	&m_mtx_wold,
						&m_mtx_wold,
						&mtx_scale);

	// 向きの設定
	D3DXMatrixRotationYawPitchRoll(	&mtx_rot,
									m_rot.y,
									m_rot.x,
									m_rot.z);

	D3DXMatrixMultiply(	&m_mtx_wold,
						&m_mtx_wold,
						&mtx_rot);
	// 位置
	D3DXMatrixTranslation(	&mtx_trans,
							m_pos.x,
							m_pos.y,
							m_pos.z);

	D3DXMatrixMultiply(	&m_mtx_wold,
						&m_mtx_wold,
						&mtx_trans);

	pDevice->GetTransform(	D3DTS_WORLD, 
							&mtx_parent);

	// パーツのワールドマトリックスと親のワールドマトリックスを掛け合わせる
	D3DXMatrixMultiply(	&m_mtx_wold,
						&m_mtx_wold,
						&mtx_parent);

	// マトリックスの設定
	pDevice->SetTransform(	D3DTS_WORLD,
							&m_mtx_wold);

	// メッシュ数分のループ
	for (int count_mesh = 0; count_mesh < mesh_size; count_mesh++)
	{
		// アニメーションがあったら
		if (m_anim_num > 0)
		{
			// ボーンがあったら
			if (m_is_bone)
			{
				BoneAnim(m_mesh[count_mesh], count_mesh);
			}
			// それ以外
			else
			{
				NoBoneAnim(m_mesh[count_mesh]);
			}
		}

		// 頂点フォーマットの設定
		pDevice->SetFVF(FVF_VERTEX_3D);

		// テクスチャのサイズを取得
		int tex_num = m_tex[count_mesh].size();

		//テクスチャ数分のループ
		for (int count_mat = 0; count_mat < tex_num; count_mat++)
		{
			// テクスチャの設定
			pDevice->SetTexture(0, m_tex[count_mesh][count_mat]);
		}

		// マテリアル数の取得
		int material_size = m_material[count_mesh].size();

		// マテリアル数分のループ
		for (int count_mat= 0; count_mat < material_size; count_mat++)
		{
			// マテリアルの設定
			pDevice->SetMaterial(&m_material[count_mesh][count_mat].MatD3D);
		}
		// 頂点バッファをデータストリームに設定
		pDevice->SetStreamSource(	0,
									m_vtx_buff[count_mesh],
									0,
									sizeof(VERTEX_3D));
		// インデックスバッファをデータストリームに設定
		pDevice->SetIndices(m_idx_buff[count_mesh]);

		// ポリゴンの描画
		pDevice->DrawIndexedPrimitive(	D3DPT_TRIANGLELIST,
										0,
										0,
										m_vertex_ary[count_mesh].size(),	// 使用する頂点数
										0,	// ここの値が最初のインデックス
										m_index_number[count_mesh].size());	// 三角形の数
	}
}

//=============================================================================
// 生成
//=============================================================================
CFbx *CFbx::Create(string pas)
{
	// fbxモデルクラス
	CFbx *buf;
	buf = new CFbx;

	// new出来てたら
	if (buf != nullptr)
	{
		// 引数の代入
		buf->m_pas = pas;

		// 初期化
		buf->Init();
	}
	return buf;
}

//=============================================================================
// ノードの再帰処理
//=============================================================================
void CFbx::RecursiveNode(FbxNode *node)
{
	FbxNodeAttribute *attrib = nullptr;	// attribのポインタ
	FbxNode *chiled = nullptr;	// 子ノードのポインタ
	int child_node_num = node->GetChildCount();	// 子ノードの数を取得

	// 子ノード数分のループ
	for (int count_node = 0; count_node < child_node_num; count_node++)
	{
		// 子ノードを取得
		chiled = node->GetChild(count_node);

		// 再帰処理
		RecursiveNode(chiled);
	}

	// ノードのattribを取得
	attrib = node->GetNodeAttribute();

	// attribがあったら
	if (attrib != nullptr)
	{
		// attribの種類を入手
		FbxNodeAttribute::EType type = attrib->GetAttributeType();

		// 種類によって処理を変える
		switch (type)
		{
		case fbxsdk::FbxNodeAttribute::eUnknown:
			break;
		case fbxsdk::FbxNodeAttribute::eNull:
			break;
		case fbxsdk::FbxNodeAttribute::eMarker:
			break;
		case fbxsdk::FbxNodeAttribute::eSkeleton:
			break;
		case fbxsdk::FbxNodeAttribute::eMesh:
			GetMesh(attrib);
			break;
		case fbxsdk::FbxNodeAttribute::eNurbs:
			break;
		case fbxsdk::FbxNodeAttribute::ePatch:
			break;
		case fbxsdk::FbxNodeAttribute::eCamera:
			break;
		case fbxsdk::FbxNodeAttribute::eCameraStereo:
			break;
		case fbxsdk::FbxNodeAttribute::eCameraSwitcher:
			break;
		case fbxsdk::FbxNodeAttribute::eLight:
			break;
		case fbxsdk::FbxNodeAttribute::eOpticalReference:
			break;
		case fbxsdk::FbxNodeAttribute::eOpticalMarker:
			break;
		case fbxsdk::FbxNodeAttribute::eNurbsCurve:
			break;
		case fbxsdk::FbxNodeAttribute::eTrimNurbsSurface:
			break;
		case fbxsdk::FbxNodeAttribute::eBoundary:
			break;
		case fbxsdk::FbxNodeAttribute::eNurbsSurface:
			break;
		case fbxsdk::FbxNodeAttribute::eShape:
			break;
		case fbxsdk::FbxNodeAttribute::eLODGroup:
			break;
		case fbxsdk::FbxNodeAttribute::eSubDiv:
			break;
		case fbxsdk::FbxNodeAttribute::eCachedEffect:
			break;
		case fbxsdk::FbxNodeAttribute::eLine:
			break;
		default:
			break;
		}
	}
}

//=============================================================================
// メッシュの入手
//=============================================================================
void CFbx::GetMesh(FbxNodeAttribute *attrib)
{
	// メッシュにダウンキャスト
	FbxMesh *mesh = static_cast<FbxMesh*>(attrib);

	// 頂点情報の取得
	GetVertex(mesh);

	// インデックス情報の取得
	GetIndex(mesh);

	// 法線情報の取得
	GetNormal(mesh);

	// 頂点カラーの取得
	GetColor(mesh);

	// UV座標の取得
	GetUv(mesh);

	// マテリアル情報の取得
	GetMaterial(mesh);

	// アニメーション情報の取得
	GetAnimInfo(mesh);

	// ボーン情報の取得
	GetBone(mesh);

	// メッシュの保存
	m_mesh.push_back(mesh);
}

//=============================================================================
// インデックス情報の取得
//=============================================================================
void CFbx::GetIndex(FbxMesh *mesh)
{
	/*int polygon_num = mesh->GetPolygonCount();	// ポリゴン数の取得
	vector<int> vetor_buf;	// vector配列のバッファ

	// ポリゴン数分のループ
	for (int count_polygon = 0; count_polygon < polygon_num; count_polygon++)
	{
		// インデックス情報の保存
		vetor_buf.push_back(count_polygon * 3 + 2);
		vetor_buf.push_back(count_polygon * 3 + 1);
		vetor_buf.push_back(count_polygon * 3);
	}
	// インデックス情報の保存
	m_index_number.push_back(vetor_buf);*/

	int polygon_num = mesh->GetPolygonCount();
	vector<int> vetor_buf;

	for (int count_polygon = 0; count_polygon < polygon_num; count_polygon++)
	{
		int vtx_num = mesh->GetPolygonSize(count_polygon);
		for (int count_vtx = 0; count_vtx < vtx_num; count_vtx++)
		{
			vetor_buf.push_back(mesh->GetPolygonVertex(count_polygon, count_vtx));
		}
	}
	m_index_number.push_back(vetor_buf);
}

//=============================================================================
// 頂点情報の取得
//=============================================================================
void CFbx::GetVertex(FbxMesh *mesh)
{
	/*int polygon_vertex_num = mesh->GetPolygonVertexCount();	// ポリゴンの頂上数の取得
	int *index_ary = mesh->GetPolygonVertices();	// ポリゴンのインデックスの取得
	FbxVector4 *src = mesh->GetControlPoints();	// 頂点座標の取得
	vector<D3DXVECTOR4> vetor_buf;	// vetor配列のバッファ

	// ポリゴンの頂点数分のループ
	for (int count_control = 0; count_control < polygon_vertex_num; count_control++)
	{
		D3DXVECTOR4 buf;	// 頂点のバッファ
		int index = index_ary[count_control];	// インデックスから配列を取得

		// 頂点情報の保存
		buf.x = static_cast<float>(-src[index][0]);
		buf.y = static_cast<float>(src[index][1]);
		buf.z = static_cast<float>(src[index][2]);
		buf.w = static_cast<float>(src[index][3]);

		// 頂点情報の保存
		vetor_buf.push_back(buf);
	}
	// 頂点情報の保存
	m_vertex_ary.push_back(vetor_buf);*/

	int control_num = mesh->GetControlPointsCount();
	FbxVector4 *src = mesh->GetControlPoints();
	vector<D3DXVECTOR4> vetor_buf;

	D3DXVECTOR4 *control_ary = new D3DXVECTOR4[control_num];
	for (int count_control = 0; count_control < control_num; count_control++)
	{
		control_ary[count_control].x = src[count_control][0];
		control_ary[count_control].y = src[count_control][1];
		control_ary[count_control].z = src[count_control][2];
		control_ary[count_control].w = src[count_control][3];

		vetor_buf.push_back(control_ary[count_control]);
	}
	m_vertex_ary.push_back(vetor_buf);
}

//=============================================================================
// 法線情報の取得
//=============================================================================
void CFbx::GetNormal(FbxMesh *mesh)
{
	FbxArray<FbxVector4> normal;	// 法線情報の配列
	vector<D3DXVECTOR3> vector_buf;	// vector配列のバッファ
	int normal_size = 0;	// 法線情報のサイズ

	mesh->GetPolygonVertexNormals(normal);	// 法線情報の取得
	normal_size = normal.Size();	// サイズを取得
	
	// 法線数分のループ
	for (int count_normal = 0; count_normal < normal_size; count_normal++)
	{
		D3DXVECTOR3 buf;	// 法線情報のバッファ

		// 法線情報の保存
		buf.x = static_cast<float>(-normal[count_normal][0]);
		buf.y = static_cast<float>(normal[count_normal][1]);
		buf.z = static_cast<float>(normal[count_normal][2]);

		// 法線情報の保存
		vector_buf.push_back(buf);
	}
	// 法線情報の保存
	m_mormal_ary.push_back(vector_buf);
}

//=============================================================================
// 頂点カラーの取得
//=============================================================================
void CFbx::GetColor(FbxMesh *mesh)
{
	vector<D3DXCOLOR> vector_col;	// カラーのvector配列
	int color_num = mesh->GetElementVertexColorCount();	// 頂点カラーのデータ数を確認

	// 頂点カラーがあったら
	if (color_num != 0)
	{
		for (int color_count = 0; color_count < color_num; color_count++)
		{
			// 頂点カラーデータの取得
			FbxGeometryElementVertexColor *color_buffer = mesh->GetElementVertexColor(color_count);

			// カラーを取得出来たら
			if (color_buffer != nullptr)
			{
				FbxLayerElement::EMappingMode mapping_mode = color_buffer->GetMappingMode();	// マッピングモード取得
				FbxLayerElement::EReferenceMode reference_mode = color_buffer->GetReferenceMode();	// リファレンスモードモード取得

				// 頂点にカラーがあるなら
				if (mapping_mode == FbxLayerElement::eByPolygonVertex)
				{
					// インデックス順に格納されていたら
					if (reference_mode == FbxLayerElement::eIndexToDirect)
					{
						FbxLayerElementArrayTemplate<FbxColor>& colors = color_buffer->GetDirectArray();	// 頂点カラーバッファ取得
						FbxLayerElementArrayTemplate<int>& indeces = color_buffer->GetIndexArray();	// 頂点カラーインデックスバッファ
						int color_num = indeces.GetCount();

						// サイズ数分のループ
						for (int count_color = 0; count_color < color_num; count_color++)
						{
							int index = indeces.GetAt(count_color);	// インデックスの取得
							FbxColor color = colors.GetAt(index);	// カラーの取得
							D3DXCOLOR col;	// カラーのバッファ

							// カラーを代入
							col.a = static_cast<float>(color.mAlpha);
							col.r = static_cast<float>(color.mRed);
							col.g = static_cast<float>(color.mGreen);
							col.b = static_cast<float>(color.mBlue);

							// カラーを保存
							vector_col.push_back(col);
						}
					}
				}
			}
		}
	}
	// カラーを保存
	m_color_ary.push_back(vector_col);
}

//=============================================================================
// UV座標の取得
//=============================================================================
void CFbx::GetUv(FbxMesh *mesh)
{
	int layer_num = mesh->GetLayerCount();	// レイヤー数の取得

	// レイヤー数分のループ
	for (int count_layer = 0; count_layer < layer_num; count_layer++)
	{
		vector<D3DXVECTOR2> vector_buf;	// vector配列のバッファ
		FbxLayer *layer = mesh->GetLayer(count_layer);	// レイヤーの取得
		FbxLayerElementUV *uv_elem = layer->GetUVs();	// UV情報の取得

		// 法線無し
		if (uv_elem == nullptr)
		{
			m_uv_ary.push_back(vector_buf);
			continue;
		}

		FbxLayerElement::EMappingMode mapping_mode = uv_elem->GetMappingMode();	// マッピングモード取得
		FbxLayerElement::EReferenceMode ref_mode = uv_elem->GetReferenceMode();	// リファレンスモードモード取得
		int uv_num = uv_elem->GetDirectArray().GetCount();	// UVの数
		int index_num = uv_elem->GetIndexArray().GetCount();	// インデックス
		int size = uv_num > index_num ? uv_num : index_num;	// サイズの設定

		// 頂点に法線があるなら
		if (mapping_mode == FbxLayerElement::eByPolygonVertex)
		{
			// 頂点順に格納されていたら
			if (ref_mode == FbxLayerElement::eDirect)
			{
				// サイズ数分のループ
				for (int count_size = 0; count_size < size; count_size++)
				{
					D3DXVECTOR2 buf;	// バッファ

					// UV座標の保存
					buf.x = static_cast<float>(uv_elem->GetDirectArray().GetAt(count_size)[0]);
					buf.y = static_cast<float>(uv_elem->GetDirectArray().GetAt(count_size)[1]);

					// UV座標の保存
					vector_buf.push_back(buf);
				}
			}
			// インデックス順に格納されていたら
			else if (ref_mode == FbxLayerElement::eIndexToDirect)
			{
				// サイズ数分のループ
				for (int count_size = 0; count_size < size; count_size++)
				{
					D3DXVECTOR2 buf;	// バッファ
					int index = uv_elem->GetIndexArray().GetAt(count_size);	// インデックスを取得

					// UV座標の保存
					buf.x = static_cast<float>(uv_elem->GetDirectArray().GetAt(index)[0]);
					buf.y = static_cast<float>(uv_elem->GetDirectArray().GetAt(index)[1]);

					// UV座標の保存
					vector_buf.push_back(buf);
				}
			}
			// UV座標の保存
			m_uv_ary.push_back(vector_buf);
		}
	}
}

//=============================================================================
// マテリアル情報の取得
//=============================================================================
void CFbx::GetMaterial(FbxMesh *mesh)
{
	vector<D3DXMATERIAL> mat_vector_buf;	// マテリアルの情報
	int material_num = mesh->GetElementMaterialCount();	// マテリアル数

	// マテリアル数分のループ
	for (int count_material = 0; count_material < material_num; count_material++)
	{
		FbxGeometryElementMaterial *material_element = mesh->GetElementMaterial();	// マテリアル情報の取得
		int index_material = material_element->GetIndexArray().GetAt(count_material);	// マテリアルのインデックスを取得
		FbxSurfaceMaterial *material = mesh->GetNode()->GetSrcObject<FbxSurfaceMaterial>(index_material);	// マテリアルの取得

		// マテリアルがあったら
		if (material != nullptr)
		{
			// マテリアルのバッファ
			D3DXMATERIAL mat_buf;

			// マテリアルの種類がLambertだったら
			if (material->GetClassId().Is(FbxSurfaceLambert::ClassId))
			{
				FbxSurfaceLambert *lambert = static_cast<FbxSurfaceLambert*>(material);	// Lambertにダウンキャスト
				FbxDouble3 fbx_ambuent = lambert->Ambient;	// Ambientカラー
				FbxDouble3 fbx_diffuse = lambert->Diffuse;	// Diffuseカラー
				FbxDouble3 fbx_emissive = lambert->Emissive;	// Emissiveカラー
				D3DXCOLOR ambient;	//	D3DXCOLO用
				D3DXCOLOR diffuse;	//	D3DXCOLO用
				D3DXCOLOR emissive;	//	D3DXCOLO用

				// D3DXMATERIAL用に直す
				ambient.r = static_cast<float>(fbx_ambuent.mData[0]);
				ambient.g = static_cast<float>(fbx_ambuent.mData[1]);
				ambient.b = static_cast<float>(fbx_ambuent.mData[2]);

				diffuse.r = static_cast<float>(fbx_diffuse.mData[0]);
				diffuse.g = static_cast<float>(fbx_diffuse.mData[1]);
				diffuse.b = static_cast<float>(fbx_diffuse.mData[2]);

				emissive.r = static_cast<float>(fbx_emissive.mData[0]);
				emissive.g = static_cast<float>(fbx_emissive.mData[1]);
				emissive.b = static_cast<float>(fbx_emissive.mData[2]);

				FbxDouble fbx_transparency = lambert->TransparencyFactor;
				float transparency = static_cast<float>(fbx_transparency);

				FbxDouble fbx_ambient_factor = lambert->AmbientFactor;
				float ambient_factor = static_cast<float>(fbx_ambient_factor);

				FbxDouble fbx_diffuse_factor = lambert->DiffuseFactor;
				float diffuse_factor = static_cast<float>(fbx_diffuse_factor);

				FbxDouble fbx_emissive_factor = lambert->EmissiveFactor;
				float emissive_factor = static_cast<float>(fbx_emissive_factor);

				// D3DXMATERIALに代入
				mat_buf.MatD3D.Ambient = ambient;
				mat_buf.MatD3D.Ambient.a = ambient_factor;
				mat_buf.MatD3D.Diffuse = diffuse;
				mat_buf.MatD3D.Diffuse.a = diffuse_factor;
				mat_buf.MatD3D.Emissive = emissive;
				mat_buf.MatD3D.Emissive.a = emissive_factor;
				mat_buf.MatD3D.Specular.a = 0.0f;
				mat_buf.MatD3D.Specular.r = 0.0f;
				mat_buf.MatD3D.Specular.g = 0.0f;
				mat_buf.MatD3D.Specular.b = 0.0f;
				mat_buf.MatD3D.Power = transparency;
			}
			// マテリアルの種類がPhongだったら
			else if (material->GetClassId().Is(FbxSurfacePhong::ClassId))
			{
				FbxSurfacePhong *phong = static_cast<FbxSurfacePhong*>(material);	// Phongにダウンキャスト
				FbxDouble3 fbx_ambuent = phong->Ambient;	// Ambientカラー
				FbxDouble3 fbx_diffuse = phong->Diffuse;	// Diffuseカラー
				FbxDouble3 fbx_emissive = phong->Emissive;	// Emissiveカラー
				FbxDouble3 fbx_specular = phong->Specular;	// Specularカラー
				D3DXCOLOR ambient;	//	D3DXCOLO用
				D3DXCOLOR diffuse;	//	D3DXCOLO用
				D3DXCOLOR emissive;	//	D3DXCOLO用
				D3DXCOLOR specular;	//	D3DXCOLO用

				// D3DXMATERIAL用に直す
				ambient.r = static_cast<float>(fbx_ambuent.mData[0]);
				ambient.g = static_cast<float>(fbx_ambuent.mData[1]);
				ambient.b = static_cast<float>(fbx_ambuent.mData[2]);

				diffuse.r = static_cast<float>(fbx_diffuse.mData[0]);
				diffuse.g = static_cast<float>(fbx_diffuse.mData[1]);
				diffuse.b = static_cast<float>(fbx_diffuse.mData[2]);

				emissive.r = static_cast<float>(fbx_emissive.mData[0]);
				emissive.g = static_cast<float>(fbx_emissive.mData[1]);
				emissive.b = static_cast<float>(fbx_emissive.mData[2]);

				specular.r = static_cast<float>(fbx_specular.mData[0]);
				specular.g = static_cast<float>(fbx_specular.mData[1]);
				specular.b = static_cast<float>(fbx_specular.mData[2]);

				FbxDouble fbx_transparency = phong->TransparencyFactor;
				float transparency = static_cast<float>(fbx_transparency);

				FbxDouble fbx_ambient_factor = phong->AmbientFactor;
				float ambient_factor = static_cast<float>(fbx_ambient_factor);

				FbxDouble fbx_diffuse_factor = phong->DiffuseFactor;
				float diffuse_factor = static_cast<float>(fbx_diffuse_factor);

				FbxDouble fbx_emissive_factor = phong->EmissiveFactor;
				float emissive_factor = static_cast<float>(fbx_emissive_factor);

				// D3DXMATERIALに代入
				mat_buf.MatD3D.Ambient = ambient;
				mat_buf.MatD3D.Diffuse = diffuse;
				mat_buf.MatD3D.Emissive = emissive;
				mat_buf.MatD3D.Specular = specular;
				mat_buf.MatD3D.Power = transparency;
			}
			// マテリアルの保存
			mat_vector_buf.push_back(mat_buf);
		}
		// テクスチャの取得
		GetTexture(material);
	}
	// マテリアルの保存
	m_material.push_back(mat_vector_buf);
}

//=============================================================================
// テクスチャの生成
//=============================================================================
void CFbx::GetTexture(FbxSurfaceMaterial *material)
{
	FbxProperty property = material->FindProperty(FbxSurfaceMaterial::sDiffuse);	// ディフューズプロパティを検索
	vector<LPDIRECT3DTEXTURE9> vector_tex_buf;	// テクスチャのvector配列バッファ
	LPDIRECT3DTEXTURE9 tex_buf = nullptr;	// テクスチャのバッファ

	// レイヤードテクスチャの数を取得
	int layer_num = property.GetSrcObjectCount<FbxLayeredTexture>();

	// レイヤードテクスチャが無ければ通常テクスチャ
	if (layer_num == 0)
	{
		// 通常テクスチャの数を取得
		int num_general_texture = property.GetSrcObjectCount<FbxFileTexture>();

		// 各テクスチャについてテクスチャ情報をゲット
		for (int count_tex = 0; count_tex < num_general_texture; count_tex++)
		{
			FbxFileTexture *texture = FbxCast<FbxFileTexture>(property.GetSrcObject(count_tex));	// テクスチャオブジェクト取得
			string absolute_file_name = texture->GetFileName();	// テクスチャファイルパスを取得（フルパス）
			string folder_name = "C:/Users/student/Desktop/Git/mini_game/プロジェクト/mini_game_00/data/Texture/Mesh/";	// パスを消す為の名前
			int folder_size = folder_name.size();	// パスのサイズ
			char *file_name;	// 名前のバッファ
			size_t size = 0;	// サイズ

			// 文字コード変換(日本語パスがダメな為)
			FbxUTF8ToAnsi(absolute_file_name.c_str(), file_name, &size);

			// 正規パスをstrigに代入
			absolute_file_name = file_name;

			// パスのサイズ数分のループ
			for (int count_erase = 0; count_erase < folder_size; count_erase++)
			{
				// 名前だけを残す
				absolute_file_name.erase(absolute_file_name.begin());
			}
			tex_buf = CManager::GetInstance()->GetTexture()->GetTexture(absolute_file_name);	// テクスチャの取得
			vector_tex_buf.push_back(tex_buf);	// テクスチャの保存
		}
		// テクスチャ無し
		if (num_general_texture <= 0)
		{
			vector_tex_buf.push_back(tex_buf);	// テクスチャの保存
		}
	}
	// マルチテクスチャ
	else
	{
		vector_tex_buf.push_back(tex_buf);	// テクスチャの保存
	}
	// テクスチャの保存
	m_tex.push_back(vector_tex_buf);
}

//=============================================================================
// アニメーション情報の取得
//=============================================================================
void CFbx::GetAnimInfo(FbxMesh *mesh)
{
	// アニメーション数取得
	m_anim_num = m_importer->GetAnimStackCount();


}

//=============================================================================
// ボーンの取得
//=============================================================================
void CFbx::GetBone(FbxMesh *mesh)
{
	int skin_num = mesh->GetDeformerCount(FbxDeformer::eSkin);	// スキンの数を取得
	vector<FbxCluster*> vector_cluster;	// クラスターのバッファ
	vector<vector<FbxAMatrix>> cluster_frame_mat;	// クラスターの毎フレームマトリッックス

	// スキン数分のループ
	for (int count_skin = 0; count_skin < skin_num; count_skin++)
	{
		// ボーン付きアニメーション
		m_is_bone = true;

		// スキンを取得
		FbxSkin *skin = static_cast<FbxSkin*>(mesh->GetDeformer(count_skin, FbxDeformer::eSkin));

		// クラスターの数を取得
		int cluster_num = skin->GetClusterCount();

		// クラスター数分のループ
		for (int count_cluster = 0; count_cluster < cluster_num; count_cluster++)
		{
			FbxCluster *cluster;	// クラスターのポインタ

			// クラスタを取得
			cluster = skin->GetCluster(count_cluster);

#ifdef _DEBUG
			auto test = cluster->GetName();
#endif // DEBUG

			FbxGlobalSettings &global_settings = m_scene->GetGlobalSettings();	// 時間設定の設定を取得
			FbxTime::EMode time_mode = global_settings.GetTimeMode();	// 時間設定の取得
			FbxAMatrix frame_mat_buf;	// フレームのマトリックス
			FbxTime start, stop, period, time;	// スタート、終了、1フレーム時間、時間
			FbxArray<FbxString*> take_name_ary;	// テイク名前
			pair<vector<int>, vector<double>> pair_index_weight;	// インデックスとウェイト
			vector<FbxAMatrix> frame_mat;	// フレームのマトリッックス	
			int num_take = 0;	// テイク数
			int start_frame = 0;	// 初期フレーム
			int stop_frame = 0;	// 終了フレーム
			int point_num = cluster->GetControlPointIndicesCount();	// ウェイトがかけられている頂点数
			int *point_ary = cluster->GetControlPointIndices();	// 頂点インデックス
			double *weight_ary = cluster->GetControlPointWeights();	// ウェイト

			// ウェイトがかけられている頂点数分のループ
			for (int count_point = 0; count_point < point_num; count_point++)
			{
				// 頂点インデックスとウェイトを取得
				int index = point_ary[count_point];
				double weight = weight_ary[count_point];

				// 最大数より大きかったら
				if (weight >= FLT_MAX)
				{
					weight = FLT_MAX;
				}
				// 最小数より小さかったら
				else if (weight <= FLT_MIN)
				{
					weight = FLT_MIN;
				}

				// 情報の保存
				pair_index_weight.first.push_back(index);
				pair_index_weight.second.push_back(weight);
			}

			// 頂点インデックスとウェイトを保存
			m_index_weight.push_back(pair_index_weight);

			// 1フレーム設定
			period.SetTime(0, 0, 0, 1, 0, time_mode);

			// テイク名の取得
			m_scene->FillAnimStackNameArray(take_name_ary);

			// テイク数の取得
			num_take = take_name_ary.GetCount();

			// テイク数分のループ
			for (int count_take = 0; count_take < num_take; count_take++)
			{
				// テイク名からテイク情報を取得
				FbxTakeInfo *current_take_info = m_scene->GetTakeInfo(*(take_name_ary[count_take]));
				if (current_take_info != nullptr)
				{
					// スタートフレームと終了フレームの取得
					start = current_take_info->mLocalTimeSpan.GetStart();
					stop = current_take_info->mLocalTimeSpan.GetStop();
					break;
				}
			}

			// スタートフレームと終了フレームの計算
			start_frame = (int)(start.Get() / period.Get());
			stop_frame = (int)(stop.Get() / period.Get());

			// フレーム数分のループ
			for (int count_frame = start_frame; count_frame < stop_frame; count_frame++)
			{
				// フレーム時間の計算
				time = (start + period) * count_frame;

				// フレームのマトリックスの取得
				frame_mat_buf = cluster->GetLink()->EvaluateGlobalTransform(period * count_frame);

				// フレームのマトリッックスを保存
				frame_mat.push_back(frame_mat_buf);
			}

			// 1アニメーションのマトリッックスを保存
			cluster_frame_mat.push_back(frame_mat);
		}
	}
	// 1アニメーションのマトリッックスを保存
	m_anim_mat.push_back(cluster_frame_mat);
}

//=============================================================================
// ボーン無しアニメーション
//=============================================================================
void CFbx::NoBoneAnim(FbxMesh *mesh)
{
	LPDIRECT3DDEVICE9 device = CManager::GetRenderer()->GetDevice();	// デバイスの取得
	FbxGlobalSettings &global_settings = m_scene->GetGlobalSettings();	// 時間設定の設定を取得
	FbxTime::EMode time_mode = global_settings.GetTimeMode();	// 時間設定の取得
	FbxTime time, start, stop, period;	// フレーム、スタート、終了、1フレーム時間
	FbxNode *node = mesh->GetNode();	// ノード
	FbxMatrix pos;	// 位置
	FbxArray<FbxString*> take_name_ary;	// テイク名前
	D3DXMATRIX mat, parent, local;	// 自分のマトリックス、親のマトリックス、ローカルマトリックス
	int num_take = 0;	// テイク数
	int start_frame = 0;	// スタートフレーム
	int stop_frame = 0;	// 終了フレーム

	// 1フレーム設定
	period.SetTime(0, 0, 0, 1, 0, time_mode);

	// テイク名の取得
	m_scene->FillAnimStackNameArray(take_name_ary);

	// テイク数の取得
	num_take = take_name_ary.GetCount();

	// テイク数分のループ
	for (int count_take = 0; count_take < num_take; count_take++)
	{
		// テイク名からテイク情報を取得
		FbxTakeInfo *current_take_info = m_scene->GetTakeInfo(*(take_name_ary[count_take]));
		if (current_take_info != nullptr)
		{
			// スタートフレームと終了フレームの取得
			start = current_take_info->mLocalTimeSpan.GetStart();
			stop = current_take_info->mLocalTimeSpan.GetStop();
			break;
		}
	}

	// アニメーションの開始位置と終了位置
	start_frame = static_cast<int>(start.Get() / period.Get());
	stop_frame = static_cast<int>(stop.Get() / period.Get());

	// 最後までアニメーションしたら
	if (m_frame_count >= stop_frame)
	{
		// 初期フレームに戻す
		m_frame_count = start_frame;
	}

	// 指定フレームのマトリックスを取得
	pos = node->EvaluateGlobalTransform(period * m_frame_count);

	// fbxmaterialをdirectx用に変換
	mat = FbxAMatToD3dxmat(pos);

	// スケール倍率を取得
	float length = D3DXVec3Length(&D3DXVECTOR3(mat._11, mat._12, mat._13));
	length = D3DXVec3Length(&D3DXVECTOR3(mat._21, mat._22, mat._23));
	length = D3DXVec3Length(&D3DXVECTOR3(mat._31, mat._32, mat._33));
	m_fbx_scale.x = length;
	m_fbx_scale.y = length;
	m_fbx_scale.z = length;

	// 親の取得
	device->GetTransform(	D3DTS_WORLD,
							&parent);

	// メッシュのワールドマトリックスと親のワールドマトリックスを掛け合わせる
	D3DXMatrixMultiply(	&mat,
						&mat,
						&parent);

	// マトリックスの設定
	device->SetTransform(	D3DTS_WORLD,
							&mat);
}

//=============================================================================
// アニメーションの更新
//=============================================================================
void CFbx::BoneAnim(FbxMesh *mesh, int mesh_count)
{
/*	LPDIRECT3DDEVICE9 device = CManager::GetRenderer()->GetDevice();	//デバイスのポインタ
	int mesh_cluster_size = m_cluster.size();	// メッシュ単位のクラスター数の取得

	// メッシュ単位のクラスター数分のループ
	for (int count_mesh_cluster = 0; count_mesh_cluster < mesh_cluster_size; count_mesh_cluster++)
	{
		// クラスター数の取得
		int cluster_size = m_cluster[count_mesh_cluster].size();

		// クラスター数分のループ
		for (int count_cluster = 0; count_cluster < cluster_size; count_cluster++)
		{
#ifdef _DEBUG
			auto test = m_cluster[count_mesh_cluster][count_cluster]->GetName();
#endif // DEBUG
			FbxGlobalSettings &global_settings = m_scene->GetGlobalSettings();	// 時間設定の設定を取得
			FbxTime::EMode time_mode = global_settings.GetTimeMode();	// 時間設定の取得
			FbxAMatrix init_mat, frame_mat, frame_mat_old, parent_fbx;	// 初期マトリックス、フレームのマトリックス、前フレームのマトリッックス、親マトリックス
			FbxTime start, stop, period, time;	// スタート、終了、1フレーム時間、時間
			FbxArray<FbxString*> take_name_ary;	// テイク名前
			D3DXMATRIX mat, parent;	// 自分のマトリックス、親のマトリックス
			pair<vector<int>, vector<float>> pair_index_weight;
			int num_take = 0;	// テイク数
			int start_frame = 0;	// 初期フレーム
			int stop_frame = 0;	// 終了フレーム
			int point_num = m_cluster[count_mesh_cluster][count_cluster]->GetControlPointIndicesCount();	// ウェイトがかけられている頂点数
			int *point_ary = m_cluster[count_mesh_cluster][count_cluster]->GetControlPointIndices();	// 頂点インデックス
			double *weight_ary = m_cluster[count_mesh_cluster][count_cluster]->GetControlPointWeights();	// ウェイト

			for (int count_point = 0; count_point < point_num; count_point++)
			{
				// 頂点インデックスとウェイトを取得
				int index = point_ary[count_point];
				float weight = static_cast<float>(weight_ary[count_point]);

				// 情報の保存
				pair_index_weight.first.push_back(index);
				pair_index_weight.second.push_back(weight);
			}

			// 1フレーム設定
			period.SetTime(0, 0, 0, 1, 0, time_mode);

			// テイク名の取得
			m_scene->FillAnimStackNameArray(take_name_ary);

			// テイク数の取得
			num_take = take_name_ary.GetCount();

			// テイク数分のループ
			for (int count_take = 0; count_take < num_take; count_take++)
			{
				// テイク名からテイク情報を取得
				FbxTakeInfo *current_take_info = m_scene->GetTakeInfo(*(take_name_ary[count_take]));
				if (current_take_info != nullptr)
				{
					// スタートフレームと終了フレームの取得
					start = current_take_info->mLocalTimeSpan.GetStart();
					stop = current_take_info->mLocalTimeSpan.GetStop();
					break;
				}
			}

			// スタートフレームと終了フレームの計算
			start_frame = (int)(start.Get() / period.Get());
			stop_frame = (int)(stop.Get() / period.Get());

			// 最後までアニメーションしたら
			if (m_frame_count >= stop_frame)
			{
				// 初期フレームに戻す
				m_frame_count = start_frame;
				m_frame_count_old = start_frame;
			}

			// 初期マトリックスの取得
			m_cluster[count_mesh_cluster][count_cluster]->GetTransformLinkMatrix(init_mat);

			// フレーム時間の計算
			time = (start + period) * m_frame_count;

			// フレームのマトリックスの取得
			frame_mat = m_cluster[count_mesh_cluster][count_cluster]->GetLink()->EvaluateGlobalTransform(time);

			//frame_mat = init_mat * frame_mat;

			// カウントが0より上
			if (m_frame_count > 0)
			{
				FbxTime old_time = (start + period) * m_frame_count_old;	// 前回の時間
				D3DXVECTOR3 rot, rot_old, difference_rot;	// 向き、前回の向き、差分の向き
				D3DXVECTOR3 pos, pos_old, difference_pos;	// 位置、前回の位置、差分の位置
				D3DXMATRIX ask_mat, ask_mat_old;	// 今のマトリッックス、前回のマトリッックス
				VERTEX_3D *vtx;	// 頂点情報

				// 前回のマトリッックス
				frame_mat_old = m_cluster[count_mesh_cluster][count_cluster]->GetLink()->EvaluateGlobalTransform(old_time);

				//frame_mat_old = init_mat * frame_mat_old;

				// 求める情報
				pos = D3DXVECTOR3(frame_mat.mData[3].mData[0], frame_mat.mData[3].mData[1], frame_mat.mData[3].mData[2]);
				pos_old = D3DXVECTOR3(frame_mat_old.mData[3].mData[0], frame_mat_old.mData[3].mData[1], frame_mat_old.mData[3].mData[2]);

				// 位置の差分
				difference_pos = pos - pos_old;

				// 頂点バッファをロックし、頂点データへのポインタを取得
				m_vtx_buff[mesh_count]->Lock(0, 0, (void**)&vtx, 0);

				// ウェイトがかけられている頂点数分のループ
				for (int count_weight_vertex = 0; count_weight_vertex < point_num; count_weight_vertex++)
				{
					D3DXVECTOR3 old_pos;	// 変更前頂点
					int vertex_size;	// 頂点サイズ

					// 変更前頂点
					old_pos = vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos;

					// 頂上情報を設定
					vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos.x = vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos.x + (difference_pos.x * pair_index_weight.second[count_weight_vertex]);
					vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos.y = vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos.y + (difference_pos.y * pair_index_weight.second[count_weight_vertex]);
					vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos.z = vtx[m_index_number[mesh_count][pair_index_weight.first[count_weight_vertex]]].pos.z + (difference_pos.z * pair_index_weight.second[count_weight_vertex]);

					vertex_size = m_vertex_ary[mesh_count].size();	// 頂点サイズの取得

					// 頂点サイズ分のループ
					for (int count_vertex = 0; count_vertex < vertex_size; count_vertex++)
					{
						// 被さり頂点だったら
						if (old_pos == vtx[count_vertex].pos)
						{
							// 頂上情報を設定
							vtx[count_vertex].pos.x = vtx[count_vertex].pos.x + (difference_pos.x * pair_index_weight.second[count_weight_vertex]);
							vtx[count_vertex].pos.y = vtx[count_vertex].pos.y + (difference_pos.y * pair_index_weight.second[count_weight_vertex]);
							vtx[count_vertex].pos.z = vtx[count_vertex].pos.z + (difference_pos.z * pair_index_weight.second[count_weight_vertex]);
						}
					}
				}

				// 頂点バッファをアンロックする
				m_vtx_buff[mesh_count]->Unlock();
			}
		}
	}*/

	int cluster_num = m_anim_mat[mesh_count].size();
	VERTEX_3D *vtx;	// 頂点情報

	// クラスター数分のループ
	for (int count_cluster = 0; count_cluster < cluster_num; count_cluster++)
	{
		D3DXVECTOR3 pos, pos_old, difference_pos;	// 位置、前回の位置、差分の位置

		if (m_frame_count >= 150)
		{
			m_frame_count = 0;
		}

		pos = D3DXVECTOR3(m_anim_mat[mesh_count][count_cluster][m_frame_count].mData[3].mData[0], m_anim_mat[mesh_count][count_cluster][m_frame_count].mData[3].mData[1], m_anim_mat[mesh_count][count_cluster][m_frame_count].mData[3].mData[2]);
		pos_old = D3DXVECTOR3(m_anim_mat[mesh_count][count_cluster][m_frame_count_old].mData[3].mData[0], m_anim_mat[mesh_count][count_cluster][m_frame_count_old].mData[3].mData[1], m_anim_mat[mesh_count][count_cluster][m_frame_count_old].mData[3].mData[2]);

		// 位置の差分
		difference_pos = pos - pos_old;

		// ウェイトがかけられている数
		int weight_num = m_index_weight[count_cluster].first.size();

		// 頂点バッファをロックし、頂点データへのポインタを取得
		m_vtx_buff[mesh_count]->Lock(0, 0, (void**)&vtx, 0);

		// ウェイト数分のループ
		for (int count_weight = 0; count_weight < weight_num; count_weight++)
		{
/*			D3DXVECTOR3 before_change_old_pos;	// 変更前頂点
			int vertex_size;	// 頂点サイズ

			// 変更前頂点
			before_change_old_pos = vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos;*/

			difference_pos = difference_pos * m_index_weight[count_cluster].second[count_weight];

			// 頂上情報を設定
			vtx[m_index_weight[count_cluster].first[count_weight]].pos.x += difference_pos.x;
			vtx[m_index_weight[count_cluster].first[count_weight]].pos.y += difference_pos.y;
			vtx[m_index_weight[count_cluster].first[count_weight]].pos.z += difference_pos.z;

/*			vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos.x = vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos.x + (difference_pos.x * m_index_weight[count_cluster].second[count_weight]);
			vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos.y = vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos.y + (difference_pos.y * m_index_weight[count_cluster].second[count_weight]);
			vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos.z = vtx[m_index_number[mesh_count][m_index_weight[count_cluster].first[count_weight]]].pos.z + (difference_pos.z * m_index_weight[count_cluster].second[count_weight]);

			vertex_size = m_vertex_ary[mesh_count].size();	// 頂点サイズの取得

			// 頂点サイズ分のループ
			for (int count_vertex = 0; count_vertex < vertex_size; count_vertex++)
			{
				// 被さり頂点だったら
				if (before_change_old_pos == vtx[count_vertex].pos)
				{
					// 頂上情報を設定
					vtx[count_vertex].pos.x = vtx[count_vertex].pos.x + (difference_pos.x * m_index_weight[count_cluster].second[count_weight]);
					vtx[count_vertex].pos.y = vtx[count_vertex].pos.y + (difference_pos.y * m_index_weight[count_cluster].second[count_weight]);
					vtx[count_vertex].pos.z = vtx[count_vertex].pos.z + (difference_pos.z * m_index_weight[count_cluster].second[count_weight]);
				}
			}*/
		}

		// 頂点バッファをアンロックする
		m_vtx_buff[mesh_count]->Unlock();
	}
}

//=============================================================================
// FbxマトリックスをDirectXマトリックスに
//=============================================================================
D3DXMATRIX CFbx::FbxAMatToD3dxmat(FbxMatrix fbx_mat)
{
	D3DXMATRIX buf;	// バッファ

	buf = D3DXMATRIX(	(float)fbx_mat.mData[0].mData[0], (float)fbx_mat.mData[0].mData[1], (float)fbx_mat.mData[0].mData[2], (float)fbx_mat.mData[0].mData[3],
						(float)fbx_mat.mData[1].mData[0], (float)fbx_mat.mData[1].mData[1], (float)fbx_mat.mData[1].mData[2], (float)fbx_mat.mData[1].mData[3],
						(float)fbx_mat.mData[2].mData[0], (float)fbx_mat.mData[2].mData[1], (float)fbx_mat.mData[2].mData[2], (float)fbx_mat.mData[2].mData[3],
						(float)fbx_mat.mData[3].mData[0], (float)fbx_mat.mData[3].mData[1], (float)fbx_mat.mData[3].mData[2], (float)fbx_mat.mData[3].mData[3]);

	return buf;
}

//=============================================================================
// ノードからローカルマトリックスの取得
//=============================================================================
D3DXMATRIX CFbx::NodeInLocalMat(FbxNode *node)
{
	// 各ローカル情報
	FbxDouble3 translation = node->LclTranslation.Get();
	FbxDouble3 rotation = node->LclRotation.Get();
	FbxDouble3 scaling = node->LclScaling.Get();

	// 計算用マトリックス
	D3DXMATRIX local, mtx_scale, mtx_rot, mtx_trans;

	// マトリックス初期化
	D3DXMatrixIdentity(&local);

	// スケールの設定
	D3DXMatrixScaling(	&mtx_scale,
						scaling[0],
						scaling[1],
						scaling[2]);

	D3DXMatrixMultiply(	&local,
						&local,
						&mtx_scale);

	// 向きの設定
	D3DXMatrixRotationYawPitchRoll(	&mtx_rot,
									rotation[0],
									rotation[1],
									rotation[2]);

	D3DXMatrixMultiply(	&local,
						&local,
						&mtx_rot);
	// 位置
	D3DXMatrixTranslation(	&mtx_trans,
							translation[0],
							translation[1],
							translation[2]);

	D3DXMatrixMultiply(	&local,
						&local,
						&mtx_trans);

	return local;
}

//=============================================================================
// マトリックスから位置の取り出し
//=============================================================================
D3DXVECTOR3 CFbx::PopMatPos(D3DXMATRIX mat)
{
	return D3DXVECTOR3(mat._41, mat._42, mat._43);
}

//=============================================================================
// マトリックスからスケールの取り出し
//=============================================================================
D3DXVECTOR3 CFbx::PopMatScale(D3DXMATRIX mat)
{
	return D3DXVECTOR3(D3DXVec3Length(&D3DXVECTOR3(mat._11, mat._12, mat._13)), D3DXVec3Length(&D3DXVECTOR3(mat._21, mat._22, mat._23)), D3DXVec3Length(&D3DXVECTOR3(mat._31, mat._32, mat._33)));
}